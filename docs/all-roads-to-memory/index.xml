<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>All Things Low Level – All Roads To Memory</title><link>https://hi-anki.github.io/gitbook/docs/all-roads-to-memory/</link><description>Recent content in All Roads To Memory on All Things Low Level</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://hi-anki.github.io/gitbook/docs/all-roads-to-memory/index.xml" rel="self" type="application/rss+xml"/><item><title>Virtual Memory</title><link>https://hi-anki.github.io/gitbook/docs/all-roads-to-memory/virtual-memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-anki.github.io/gitbook/docs/all-roads-to-memory/virtual-memory/</guid><description>
&lt;p&gt;&lt;em&gt;&lt;strong&gt;August 11, 2025&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Premise&lt;span class="hx:absolute hx:-mt-20" id="premise"&gt;&lt;/span&gt;
&lt;a href="#premise" class="subheading-anchor" aria-label="Permalink for this section"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Virtual memory is quite extensive, so diving in directly is foolish. Therefore, here is a tasting of each concept.&lt;/p&gt;
&lt;h2&gt;Physical Memory&lt;span class="hx:absolute hx:-mt-20" id="physical-memory"&gt;&lt;/span&gt;
&lt;a href="#physical-memory" class="subheading-anchor" aria-label="Permalink for this section"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Byte-addressable&lt;/strong&gt;: each address refers to 1-byte.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flat address space&lt;/strong&gt;: goes from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;total_bytes - 1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Linux abstracts physical memory into &lt;strong&gt;page frames&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Physical addresses aren&amp;rsquo;t directly visible (and accessible). The visible addresses are in &lt;strong&gt;virtual memory&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Virtual addresses are mapped into physical address space by the Memory Management Unit (MMU).&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Virtual Memory&lt;span class="hx:absolute hx:-mt-20" id="virtual-memory"&gt;&lt;/span&gt;
&lt;a href="#virtual-memory" class="subheading-anchor" aria-label="Permalink for this section"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Every process is allotted a virtual address space, which gives a fake sense of owning all the memory.&lt;/li&gt;
&lt;li&gt;Each process gets the same address layout, which gives predictability.&lt;/li&gt;
&lt;li&gt;The addresses generally visible are from VAS.&lt;/li&gt;
&lt;li&gt;MMU with the OS manages to translate these addresses to physical memory mappings.&lt;/li&gt;
&lt;li&gt;Processes can&amp;rsquo;t directly see each other&amp;rsquo;s memory.&lt;/li&gt;
&lt;li&gt;Virtual memory is divided into pages of 4 KiB (other configs also available, but 4 KiB is the most widely used).&lt;/li&gt;
&lt;li&gt;Each page in virtual memory maps to a page in physical memory.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Virtual Address Space&lt;span class="hx:absolute hx:-mt-20" id="virtual-address-space"&gt;&lt;/span&gt;
&lt;a href="#virtual-address-space" class="subheading-anchor" aria-label="Permalink for this section"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Address space is the set of all addresses available for a program to use.&lt;/p&gt;
&lt;p&gt;MMU with the OS manages to translate these addresses to physical memory.&lt;/p&gt;
&lt;p&gt;Virtual address space is split into &lt;em&gt;user space&lt;/em&gt; and &lt;em&gt;kernel space&lt;/em&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;User space is where the program runs.&lt;/li&gt;
&lt;li&gt;Kernel space is where the OS runs.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Page&lt;span class="hx:absolute hx:-mt-20" id="page"&gt;&lt;/span&gt;
&lt;a href="#page" class="subheading-anchor" aria-label="Permalink for this section"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;A page is the smallest fixed-size chunk of memory that the CPU and the OS manages together.&lt;/p&gt;
&lt;p&gt;In most modern x86-64 Linux systems: 1 page = 4 KiB (4096 bytes). There exist huge pages (2 MiB, 1 GiB) as well, but 4 KiB is the baseline.&lt;/p&gt;
&lt;p&gt;Page size is a hardware choice, not just an OS thing.&lt;/p&gt;
&lt;p&gt;Every virtual address is a part of some page.&lt;/p&gt;
&lt;p&gt;Paging solves three problems:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Memory isolation → each process has its own mapping from virtual pages to physical frames.&lt;/li&gt;
&lt;li&gt;Flexible allocation → you can give a process scattered physical memory but make it look contiguous.&lt;/li&gt;
&lt;li&gt;Protection → per-page permissions: read, write, execute.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;A &lt;strong&gt;Page&lt;/strong&gt; is a portion of memory in the virtual address space. A &lt;strong&gt;Page frame&lt;/strong&gt; is the portion of memory in the physical space that maps to a page in virtual space.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Basically, &lt;strong&gt;page&lt;/strong&gt; is a virtual memory term and &lt;strong&gt;page frame&lt;/strong&gt; is a physical memory term.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Page table&lt;/strong&gt; is a data structure that the MMU uses to translate an address in virtual space to its corresponding address in the physical memory space.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;page table entry&lt;/strong&gt; (PTE) is a mapping record from a page to frame with permissions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MMU&lt;/strong&gt; is a piece of hardware that uses page tables to translate addresses.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;A page fault occurs when the CPU tries to access a virtual address, but the page table entry for that address says:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the page is not present in RAM, or&lt;/li&gt;
&lt;li&gt;the access violates permissions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The CPU stops the instruction and hands control to the OS so it can handle the situation.&lt;/p&gt;
&lt;h2&gt;Memory Size Unit&lt;span class="hx:absolute hx:-mt-20" id="memory-size-unit"&gt;&lt;/span&gt;
&lt;a href="#memory-size-unit" class="subheading-anchor" aria-label="Permalink for this section"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;KB can be ambiguous as it may represent both the binary and the decimal representations, which vary greatly in terms of value.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 KB is 1000 bytes while 1 KiB is 1024 bytes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will use the &lt;code&gt;i&lt;/code&gt; ones because they are more relevant here.&lt;/p&gt;</description></item><item><title>Dynamic Memory Allocation</title><link>https://hi-anki.github.io/gitbook/docs/all-roads-to-memory/dma/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hi-anki.github.io/gitbook/docs/all-roads-to-memory/dma/</guid><description>
&lt;p&gt;&lt;em&gt;&lt;strong&gt;9, 10, 15 September 2025&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;These are the primary functions used for dynamic memory allocation in C. These are wrappers in libc/glibc. The underlying machinery that powers them is called the &lt;strong&gt;allocator program&lt;/strong&gt;.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Returned pointer is aligned for any built-in type.&lt;/p&gt;
&lt;p&gt;Assembly just calls these functions and waits for &lt;code&gt;rax&lt;/code&gt; to get the pointer to the memory.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;An &lt;strong&gt;allocator&lt;/strong&gt; is the program that manages dynamic memory requirements.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each process gets its own &lt;strong&gt;allocator instance&lt;/strong&gt;, which manages its dynamic memory requirements.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are multiple implementations of allocator, each designed for specific project requirements. We can create our own allocator program as well.&lt;/p&gt;
&lt;p&gt;The most widely used allocators include:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ptmalloc&lt;/code&gt;: GNU&amp;rsquo;s implementation for glibc, written by Wolfram Gloger.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tcmalloc&lt;/code&gt; : Google&amp;rsquo;s implementation for their C/C++ projects.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jemalloc&lt;/code&gt; : Created by Jason Evans for a programming language project but came out as a great memory allocator which was integrated into FreeBSD and various other platforms like Facebook and Firefox use it. &lt;a href="https://jasone.github.io/2025/06/12/jemalloc-postmortem/"target="_blank" rel="noopener"&gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But the father of all allocators, not the first memory allocator, but definitely the most significant and influential one was &lt;code&gt;dlmalloc&lt;/code&gt;. This is what we are going to start with.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dlmalloc&lt;/code&gt; stands for Doug Lea&amp;rsquo;s memory allocator implementation.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;He is a professor of CS at State University of New York at Oswego.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/DenizThatMenace/dlmalloc"target="_blank" rel="noopener"&gt;This repository&lt;/a&gt; has every version of dlmalloc.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/aradzie/dlmalloc"target="_blank" rel="noopener"&gt;This repository&lt;/a&gt; has a clear version of dlmalloc as the the original version uses a strange dialect of C which is not beginner friendly.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/emeryberger/Malloc-Implementations"target="_blank" rel="noopener"&gt;This repository&lt;/a&gt; has multiple allocator implementations under one roof.&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>