---
id: 74f6fea8f48c45c9af3f0037a3c4d69d
title: Introduction To objdump
weight: 1
---

***Originally written between late june and early july 2025***

***Polished on October 03, 2025***

***Make sure you have read the {{< doclink "9d652181ee714f7988c5ed164e4cae4e" "compilation" >}} write up.***

---

`objdump` (object dump), is a versatile tool from the GNU project, which displays information from object files. It essentially reads them.

It can be used as:
```bash
objdump ELF FLAGS
```

It can do a lot of things, but we will use it as a disassembler, a program that extracts assembly out of an ELF file.
```bash
objdump hello.o -D -M intel   # Complete disassembly using Intel syntax
objdump hello.o -t            # Symbol table
objdump hello.o -r            # Relocation entries
objdump hello.o -h            # Section headers
```

Let's start by full disassembly.

## Full Disassembly (-D)

```bash
$ objdump hello.o -D -M intel

hello.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
   0:	55                   	push   rbp
   1:	48 89 e5             	mov    rbp,rsp
   4:	48 8d 05 00 00 00 00 	lea    rax,[rip+0x0]        # b <main+0xb>
   b:	48 89 c7             	mov    rdi,rax
   e:	e8 00 00 00 00       	call   13 <main+0x13>
  13:	b8 00 00 00 00       	mov    eax,0x0
  18:	5d                   	pop    rbp
  19:	c3                   	ret

Disassembly of section .rodata:

0000000000000000 <.rodata>:
   0:	48                   	rex.W
   1:	65 6c                	gs ins BYTE PTR es:[rdi],dx
   3:	6c                   	ins    BYTE PTR es:[rdi],dx
   4:	6f                   	outs   dx,DWORD PTR ds:[rsi]
   5:	2c 20                	sub    al,0x20
   7:	57                   	push   rdi
   8:	6f                   	outs   dx,DWORD PTR ds:[rsi]
   9:	72 6c                	jb     77 <main+0x77>
   b:	64 21 00             	and    DWORD PTR fs:[rax],eax

Disassembly of section .comment:

0000000000000000 <.comment>:
   0:	00 47 43             	add    BYTE PTR [rdi+0x43],al
   3:	43 3a 20             	rex.XB cmp spl,BYTE PTR [r8]
   6:	28 44 65 62          	sub    BYTE PTR [rbp+riz*2+0x62],al
   a:	69 61 6e 20 31 34 2e 	imul   esp,DWORD PTR [rcx+0x6e],0x2e343120
  11:	32 2e                	xor    ch,BYTE PTR [rsi]
  13:	30 2d 31 39 29 20    	xor    BYTE PTR [rip+0x20293931],ch        # 2029394a <main+0x2029394a>
  19:	31 34 2e             	xor    DWORD PTR [rsi+rbp*1],esi
  1c:	32 2e                	xor    ch,BYTE PTR [rsi]
  1e:	30 00                	xor    BYTE PTR [rax],al

Disassembly of section .eh_frame:

0000000000000000 <.eh_frame>:
   0:	14 00                	adc    al,0x0
   2:	00 00                	add    BYTE PTR [rax],al
   4:	00 00                	add    BYTE PTR [rax],al
   6:	00 00                	add    BYTE PTR [rax],al
   8:	01 7a 52             	add    DWORD PTR [rdx+0x52],edi
   b:	00 01                	add    BYTE PTR [rcx],al
   d:	78 10                	js     1f <.eh_frame+0x1f>
   f:	01 1b                	add    DWORD PTR [rbx],ebx
  11:	0c 07                	or     al,0x7
  13:	08 90 01 00 00 1c    	or     BYTE PTR [rax+0x1c000001],dl
  19:	00 00                	add    BYTE PTR [rax],al
  1b:	00 1c 00             	add    BYTE PTR [rax+rax*1],bl
  1e:	00 00                	add    BYTE PTR [rax],al
  20:	00 00                	add    BYTE PTR [rax],al
  22:	00 00                	add    BYTE PTR [rax],al
  24:	1a 00                	sbb    al,BYTE PTR [rax]
  26:	00 00                	add    BYTE PTR [rax],al
  28:	00 41 0e             	add    BYTE PTR [rcx+0xe],al
  2b:	10 86 02 43 0d 06    	adc    BYTE PTR [rsi+0x60d4302],al
  31:	55                   	push   rbp
  32:	0c 07                	or     al,0x7
  34:	08 00                	or     BYTE PTR [rax],al
	...

```

The assembly generated after compilation is different than the assembly generated by objdump. This is because assembling transforms that assembly in various ways and objdump reads that transformed object code and work backwards to obtain assembly instructions from machine instructions.

***

There is no sign of the original "Hello, World!\n" string in the disassembly as it is present in encoded form.

It is present in the `.rodata` section because anything that goes inside the `printf` function is immutable by design.
```bash
Disassembly of section .rodata:

0000000000000000 <.rodata>:
    0:	  48                   	rex.W
    1:	  65 6c                	gs ins BYTE PTR es:[rdi],dx
    3:	  6c                   	ins    BYTE PTR es:[rdi],dx
    4:	  6f                   	outs   dx,DWORD PTR ds:[rsi]
    5:	  2c 20                	sub    al,0x20
    7:	  57                   	push   rdi
    8:	  6f                   	outs   dx,DWORD PTR ds:[rsi]
    9:	  72 6c                	jb     77 <main+0x77>
    b:	  64 21 00             	and    DWORD PTR fs:[rax],eax

# Offset  Machine Code          Disassembly
```

Open an ASCII/string to hex converter and paste original string. You will get:
```
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64
```

Open an ASCII to HEX reference and map these values. You will get:
```
48(H) 65(e) 6C(l) 6C(l) 6F(o) 2C(,) 20(SP) 57(W) 6F(o) 72(r) 6C(l) 64(d)
```

This confirms the existence of the original string.

## Symbol Table (-t)

The output is slightly formatted for better understanding.
```bash
SYMBOL TABLE:
0000000000000000      l          df        *ABS*       0000000000000000    hello.c
0000000000000000      l          d         .text       0000000000000000    .text
0000000000000000      l          d         .rodata     0000000000000000    .rodata
0000000000000000      g          F         .text       000000000000001a    main
0000000000000000                           *UND*       0000000000000000    puts

# Value (Offset   Linker       Symbol    Section it    Size of symbol     Symbol name
# relative to     Visibility   Type      belongs to
# section)
```

The first column is for offsets (at which the symbol is present in the binary) relative to the address where the binary is loaded.
  - As the symbols require relocation, the `00...` act as a placeholder for the actual offset.

The second column shows whether the symbol is visible to the linker or not.
  - `l`: local; `g`: global.
  - Only `main` has global visibility, because we made it so.

The third column is for symbol type.
  - `d`: section definition (debug symbol).
  - `F`: function symbol
  - `f`: file name symbol.
  - `df`: file definition (name). Remember the `.file` directive?

The fourth section is for the section the symbol belongs to.
  - `*ABS*`: absolute symbol, not relocatable.
  - `*UND*` refers to an undefined symbol which requires relocation.

We have used `printf()` objdump shows the object code is using `puts()`. This is because printf is a more complex function and we are not doing anything complex. So `gcc` optimized the code to use `puts`.

## Section Headers (-h)

The output is slightly modified.
```bash
Sections:
Idx         Name             Size       VMA               LMA               File off     Algn
  0         .text            0000001a   0000000000000000  0000000000000000  00000040     2**0
                          └─ CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1         .data            00000000   0000000000000000  0000000000000000  0000005a     2**0
                          └─ CONTENTS, ALLOC, LOAD, DATA
  2         .bss             00000000   0000000000000000  0000000000000000  0000005a     2**0
                          └─ ALLOC
  3         .rodata          0000000e   0000000000000000  0000000000000000  0000005a     2**0
                          └─ CONTENTS, ALLOC, LOAD, READONLY, DATA
  4         .comment         00000020   0000000000000000  0000000000000000  00000068     2**0
                          └─ CONTENTS, READONLY
  5         .note.GNU-stack  00000000   0000000000000000  0000000000000000  00000088     2**0
                          └─ CONTENTS, READONLY
  6         .eh_frame        00000038   0000000000000000  0000000000000000  00000088     2**3
                          └─ CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA

# Section   Section          Size in   Virtual Memory      Load Memory      Offset In    Alignment
# Index     Name             Bytes     Addrress            Address          File Where   Requirement
#                                                                           It Begins
```

`CONTENTS, ALLOC, LOAD, DATA, RELOC, READONLY, CODE` are flags.

  - `CONTENTS`: has data in the file.
  - `ALLOC`: should exist in memory at runtime.
  - `LOAD`: should be loaded by the linker/loader program.
  - `RELOC`: has relocation entries.
  - `READONLY`: not writable.
  - `CODE`: contains executable instructions.
  - `DATA`: contains data.

What is `VMA` and `LMA` ?
  - We are going to talk about this soon.

---

We are done with objdump. Next is readelf.